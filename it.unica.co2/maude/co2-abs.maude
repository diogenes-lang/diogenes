in contracts .

mod CO2-ABS is
    ***extending CONTR-SYNTAX .
    protecting CONTR-UTILS .


    sorts ACLabel LUniContract .

    subsort IOAction < ACLabel .
    subsort RdyContract < LUniContract .

    op block _._ : InAction UniContract -> RdyContract .

    op ctx:_ : IOAction -> ACLabel [ctor] .
    op {_}_ : ACLabel RdyContract -> LUniContract [ctor frozen].     

    var il : InAction .
    var ol : OutAction .
    var c : UniContract .
    var ci : IChoice .
    var ce : EChoice .
    vars g g' : RdyContract .
    var l l' : ACLabel .  
    
    rl ol . c (+) ci => {ol} block co(ol) . c .
    rl ready il . c => {il} c .
    rl il . c + ce => {ctx: (co(il))} ready il . c .
    rl block il . c => {ctx: il} c . 

    ***semantics
    sort TUniContract .    
    op <_> : LUniContract -> TUniContract [frozen] .

    op dummy : -> ACLabel [ctor] .
    
    *** crl [Rifl] : [g] => [{l} g'] if g =>  {l} g' .
    eq < g > = < {dummy} g > .

    crl [Rifl] : < {l'} g > => < {l} g' > if g => {l} g' .

endm

mod ASK-ABS is
    protecting CO2-ABS .
    including SATISFACTION .
    including MODEL-CHECKER .
    including LTL-SIMPLIFIER .

    subsort TUniContract < State .

    subsort IOAction < Prop .

    var g : RdyContract .
    var a : IOAction .
    var phi : Formula .

    eq < {a} g > |= a = true .
    eq < {ctx: a} g > |= a = true .
    ***eq T:TUniContract |= a = false [owise] .
    
    op _ |- _ : RdyContract Formula -> Bool [frozen] .

    eq g |- phi = modelCheck(< g > , phi) == true .
endm

mod CO2-ABS-SYNTAX is
	protecting ASK-ABS .
    including NAT .
    including STRING .
	
	sorts System Process Prefix SessionName SessionVariable SessionIde GuardProc Sum IdeVec ProcIde ParamList Expression .
	subsort SessionName < SessionIde < IdeVec .
	subsort String < SessionVariable < SessionIde < IdeVec . 
	subsort GuardProc < Sum < Process .
    subsort SessionIde < ParamList .
   subsort Expression < ParamList .

    op void : -> ParamList [ctor] .
    op empty : -> IdeVec [ctor] .

    op 0 : -> System [ctor] .
    op 0 : -> Sum [ctor] .

    op t : -> Prefix [ctor] .

    op _;_ : ParamList ParamList -> ParamList [ctor assoc id: void prec 20] .
	op _,_ : IdeVec IdeVec -> IdeVec [comm assoc ctor id: empty] .

	op _[_] : Participant Process -> System [frozen ctor prec 20] .
	op _[_] : SessionName RdyContract -> System [frozen ctor prec 20] .
	op _|_ : System System -> System [comm assoc frozen ctor id: 0 prec 35] .
	op (_)_ : IdeVec System -> System [frozen ctor prec 33] .
	op {__}_ : SessionIde UniContract Participant -> System [frozen ctor prec 20] .
	op _._ : Prefix Process -> GuardProc [frozen ctor prec 25] .
	op _+_ : Sum Sum -> Sum [comm assoc frozen ctor id: 0 prec 30] .
	op _|_ : Process Process -> Process [comm assoc frozen ctor id: 0 prec 35] .
	op (_)_ : IdeVec Process -> Process [frozen ctor prec 33] .
	op tell __ : SessionIde UniContract -> Prefix [frozen ctor prec 20] .
	op do __ : SessionIde IOAction -> Prefix [frozen ctor prec 20] .
    	op ask __ : SessionIde Formula -> Prefix [frozen ctor prec 20] .
    	op _(_) : ProcIde ParamList -> Process [frozen ctor prec 20] .
    	op if _ then _ else _ : Expression Process Process -> Process [frozen ctor prec 36] .


    op $_ : Nat -> SessionName [ctor prec 20] .
    op __ : String Nat -> SessionVariable [ctor prec 20] .

    sorts Process? Env .
    subsort Process < Process? .

    op _(_)=def_ : ProcIde ParamList Process -> Env [frozen prec 40] .
    op emptyEnv : -> Env .
    op _&_ : Env Env -> Env [assoc comm id: emptyEnv prec 42] .
    op _definedIn_ : ProcIde Env -> Bool .
    op def : ProcIde Env -> Process? .
    op param : ProcIde Env -> ParamList .
    op not-defined : -> Process? .

    op env : -> Env .

    vars u u' v : SessionIde .
    vars x x' : SessionVariable .
	vars uVec vVec : IdeVec .
    vars uList vList uList' vList' : ParamList .
	vars s s' : SessionName .
	var A : Participant .
	vars P Q Q' : Process .
	vars S S' : System .
	var pi : Prefix .
    var fi : Formula .
	vars M N : Sum .
	var a : IOAction .
	var c : UniContract .
    var n : Nat .
    vars X X' : ProcIde .
    var Y : Var .
    vars E E' : Env .
    var q : String .
    var g : RdyContract .
    var ci : IChoice .
    var ce : EChoice .
    vars e e' : Expression .

    op _(_)=def_ : ProcIde ParamList Process -> Env [frozen prec 40] .
    op emptyEnv : -> Env .
    op _&_ : Env Env -> Env [assoc comm id: emptyEnv prec 42] .
    op _definedIn_ : ProcIde Env -> Bool .
    op def : ProcIde Env -> Process? .
    op param : ProcIde Env -> ParamList .
    op not-defined : -> Process? .

    op env : -> Env .

    eq X definedIn emptyEnv = false .
    eq X definedIn (X' (uList) =def P & E) = (X == X') or (X definedIn E) .
    eq def(X, emptyEnv) = not-defined .
    eq def(X, (X' (uList) =def P) & E) = if X == X' then P else def(X, E) fi .
    eq param(X, (X' (uList) =def P) & E) = if X == X' then uList else param(X, E) fi .
    eq param(X, emptyEnv) = empty .

	***substitution of free variables
    op _{_/_} : System SessionIde SessionIde -> System .
    op _{_/_} : Process SessionIde SessionIde -> Process .
    op _{_/_} : ParamList SessionIde SessionIde -> ParamList .

    eq (u' ; uList) {u / v} = if v == u' then u ; (uList{u / v}) else u' ;  (uList{u / v}) fi .
    eq e ; uList {u / v} = e ; (uList{u / v}) .
    eq void {u / v} = void .
    eq (0).Process {u / v} = (0).Process .
    eq t . P {u / v} = t . (P {u / v}) .
    eq tell u' c . P {u / v} = if v == u' then tell u c . (P {u / v}) else tell u' c . (P {u / v}) fi .
    eq ask u' fi . P {u / v} = if v == u' then ask u fi . (P {u / v}) else ask u' fi . (P {u / v}) fi .
    eq do u' a . P {u / v} = if v == u' then do u a . (P{u / v}) else do u' a . (P {u / v}) fi .
    ceq M + N {u / v} = (M {u / v}) + (N {u / v}) if M =/= 0 /\ N =/= 0 .
    ceq P | Q {u / v} = (P {u / v}) | (Q {u / v}) if P =/= 0 /\ Q =/= 0 .
    eq (if e then P else Q){u / v} = if e then (P{u / v}) else (Q{u / v}) .
    eq (v , uVec) P {u / v} = (v , (uVec{u / v})) P .
    eq (uVec) P {u / v} = (uVec) (P {u / v}) [owise] . 
    eq {u' c}A {u / v} = if v == u' then {u c}A else {u' c}A fi .
    eq A[P] {u / v} = A[P {u / v}] .
    eq s[g] {s' / v} = if s == v then s'[g] else s[g] fi .
    eq s[g] {x / v} = s[g] . 
    eq X(uList) {u / v} = X(uList{u / v}) .
    ceq S | S' {u / v} = (S{u / v}) | (S'{u / v}) if S =/= 0 /\ S' =/= 0 .
    eq (v , uVec) S {u / v} = (v , uVec) S .
    eq (uVec) S {u / v} = (uVec) (S {u / v}) [owise] . 

	op _ in _ : SessionIde IdeVec -> Bool .

    eq u in (u , uVec) = true . 
    eq u in uVec = false [owise] .

    op _ in _ : SessionIde ParamList -> Bool .

    eq u in void = false .
    eq u in (v ; uList) = if u == v then true else u in uList fi .
    eq u in (e ; uList) = u in uList .     

    op is _ free in _ : SessionIde System -> Bool .
    op is _ free in _ : SessionIde Process -> Bool .
    op is _ free in _ : SessionIde Prefix -> Bool .

    eq is u free in (uVec) S = (not u in uVec) and is u free in S . 
    eq is u free in (uVec) P = (not u in uVec) and is u free in P .  
	eq is u free in (0).System = false .
    eq is u free in (0).Process = false .
	eq is u free in A[P] = is u free in P .
	eq is u free in s[g] = u == s .
    eq is u free in {v c}A = u == v .
	ceq is u free in S | S' = is u free in S or is u free in S' if S =/= 0 and S' =/= 0 .
    ceq is u free in P | Q = is u free in P or is u free in Q if P =/= 0 and Q =/= 0 .
	ceq is u free in M + N = is u free in M or is u free in N if N =/= 0 and M =/= 0 .
    eq is u free in if e then P else Q = is u free in P or is u free in Q .
    eq is u free in pi . P = is u free in pi or is u free in P .
	eq is u free in do v a = u == v .
	eq is u free in t = false .
	eq is u free in tell v c = u == v .
    eq is u free in ask v fi = u == v .
    eq is u free in X(uList) = u in uList .

    op alpha : System System SessionIde -> SessionVariable .
    op alpha : Process Process SessionIde -> SessionVariable .
    
    eq alpha (S , S' , q n) = if not is (q n) free in S and not is (q n) free in S' then q n else alpha (S , S' , q (n + 1)) fi .
    eq alpha (S , S' , q) = alpha(S , S' , q 0) [owise] .
    eq alpha (P , Q , q n) = if not is (q n) free in P and not is (q n) free in Q then q n else alpha (P , Q , q (n + 1)) fi .
    eq alpha (P , Q , q) = alpha(P , Q , q 0) [owise] .
    eq alpha (S , S' , $ n) = if not is ($ n) free in S and not is ($ n) free in S' then $ n else alpha (S , S' , $ (n + 1)) fi .
    eq alpha (P , Q , $ n) = if not is ($ n) free in P and not is ($ n) free in Q then $ n else alpha (P , Q , $ (n + 1)) fi .

    ***structural equivalence. Equations are not commutative
    eq (u , u) = u .
	ceq S | ((u,uVec)S') = ((u)(S | (uVec)S')) if S =/= 0 /\ not is u free in S .
    ceq S | ((u,uVec)S') = (v)(S | (((uVec) S'){v / u})) if S =/= 0 /\ v := alpha(S , S' , u) [owise] .
	ceq P | ((u,uVec)Q) = ((u)(P | (uVec)Q)) if P =/= 0 /\ not is u free in P .
    ceq P | ((u,uVec)Q) = (v)(P | (((uVec) Q){v / u})) if P =/= 0 /\ v := alpha(P , Q , u) [owise] .
    ceq if e then P else ((u,uVec)Q) = (u) (if e then P else ((uVec)Q)) if not is u free in P .
    ceq if e then P else ((u,uVec)Q) = (v) (if e then P else (((uVec)Q){v / u})) if v := alpha(P , Q , u) [owise] .
	***ceq ((u)S) = S if not is u free in S .
	ceq ((u,uVec)S) = (uVec) S if not is u free in (uVec)S .
    ***ceq ((u)P) = P if not is u free in P .
	ceq ((u,uVec)P) = (uVec) P if not is u free in (uVec)P .
	eq {s c}A = 0 .
	eq A[(uVec)P] = (uVec)(A[P]) .
	eq ((uVec)(vVec) S) = ((uVec , vVec) S) .
	eq ((uVec)(vVec) P) = ((uVec , vVec) P) .
    eq (empty) S = S .
    eq (empty) P = P .
    ceq A[X(uList) | P] = A[(def(X,env){uList / param(X,env)}) | P] if X definedIn env .
   eq (if e then P else Q){u / v} = if e then (P{u / v}) else (Q{u / v}) .

    sort ParamListPair .
    op (_&_) : ParamList ParamList -> ParamListPair .

    op _-_ : ParamListPair SessionIde -> ParamListPair .

    eq (u ; uList & v ; vList) - v = (uList & vList) .
    eq (e ; uList & e' ; vList) - v = (uList & vList) - v .
    eq (void & void) - v = (void & void) .
    ceq (u ; uList & v ; vList) - u' = (u ; uList' & v ; vList') if (uList' & vList') := (uList & vList) - u' [owise] .

    op _{_/_} : Process ParamList ParamList -> Process .
    op _{_/_} : SessionIde ParamList ParamList -> SessionIde . 
    op _{_/_} : ParamList ParamList ParamList -> ParamList .

    eq u{u' ; uList / x ; vList} = if u == x then u' else u{uList / vList} fi .
    eq u{e ; uList / e' ; vList} = u{uList / vList} .
    eq u{void / void} = u .

    eq u ; uList'{uList / vList} = (u{uList / vList}) ; (uList'{uList / vList}) .
    eq e ; uList'{uList / vList} = e ; (uList'{uList / vList}) .
    eq void {uList / vList} = void .
    
    eq (0).Process {uList / vList} = 0 .
    eq t . P {uList / vList} = t . (P{uList / vList}) .
    eq do u a . P {uList / vList} = do (u {uList / vList}) a . (P{uList / vList}) .
    eq ask u fi . P {uList / vList} = ask (u {uList / vList}) fi . (P{uList / vList}) .
    eq tell u c . P {uList / vList} = tell (u {uList / vList}) c . (P{uList / vList}) .
    ceq N + M {uList / vList} = (N{uList / vList}) + (M{uList / vList}) if N =/= 0 /\ M =/= 0 .
    ceq P | Q {uList / vList} = (P{uList / vList}) | (Q{uList / vList}) if P =/= 0 /\ Q =/= 0 .
    eq (if e then P else Q) {uList / vList} = if e then (P{uList / vList}) else (Q{uList / vList}) .
    ceq (u , uVec) P {uList / vList} = (u)Q if (uList' & vList') := (uList & vList) - u /\ Q := (uVec) P {uList' / vList'} .
    eq X(uList'){uList / vList} = X(uList'{uList / vList}) .

    eq s[rec Y . ci] = s[(ci {(rec Y . ci) / Y})] .  
    eq s[rec Y . ce] = s[ce {(rec Y . ce) / Y}] .

    eq X(uList'){uList / vList} = X(uList'{uList / vList}) .   

endm

mod CO2-ABS-SEM is
    ***protecting CO2-ABS .
    protecting CO2-ABS-SYNTAX .
    including META-LEVEL .
    ***including NAT .
    sort SysSet .

    subsort System < SysSet .

    op empty : -> SysSet .
    op _,_ : SysSet SysSet -> SysSet [comm assoc frozen] .

    op A : -> Participant [ctor] .

    sorts LSystem ASLabel .

    subsort System < LSystem .

    op _:_ : Participant Prefix -> ASLabel [ctor] .
    op _:if : Participant -> ASLabel [ctor] .
    op ctx : -> ASLabel [ctor] .
    
    ***operatore necessario per simulare un labelled transition system
	op {_}_ : ASLabel System -> LSystem [frozen ctor] .
    
    vars P Q Q' : Process .
    vars S S' S'' : System .
    var P' : Sum .
    vars c c' : UniContract .
    vars g g' : RdyContract .
    vars u v : SessionIde .
    vars x y : SessionVariable .
    var s : SessionName .
    var a : IOAction .
    var pi : Prefix .
    var uVec : IdeVec .
    var X : ProcIde .
    var mu : ASLabel .
    vars n m : Nat .
    var uList : ParamList .
    var fi : Formula .
    var l : ACLabel .
    var e : Expression .
    var set : SysSet .

    op del : IdeVec Prefix -> Prefix .
    eq del((u , uVec) , do u a) = t .
    eq del((u , uVec) , tell u c) = t .
    eq del((u , uVec) , ask u fi) = t .
    eq del(uVec , pi) = pi [owise] .

    op fresh : Nat System -> SessionName .
    eq fresh(n , S) = if not is $ n free in S then $ n else fresh(n + 1 , S) fi .

    rl [Tau] : A[t . P + P' | Q] => {A : t} A[P | Q] . 
    
    rl [Tell] : A[tell u c . P + P' | Q] => {A : tell u c} A[P | Q] | {u c} A .

    crl [Do] : A[do s a . P + P' | Q] | s[g] => {A : do s a} A[P | Q] | s[g'] if g => {a} g' . 

    crl [Del] : (uVec) S => {A : del(uVec,pi)}(uVec) S' if S => {A : pi} S' .

    crl [Del] : (uVec) S => {ctx}(uVec) S' if S => {ctx} S' .

    crl [Del] : (uVec) S => {A :if} (uVec) S' if S => {A :if} S' .

    crl [Par] : S | S'' => {mu} (S' | S'') if S =/= 0 /\ S'' =/= 0 /\ S => {mu} S' . 

    crl [DoCTX] : s[g] => {ctx} s[g'] if g => {l} g' /\ ctx: a := l .

    crl [AskCTX] : s[g] | A[ask s fi . P + P' | Q] => {ctx} s[g] | A[P | Q] if not g |- (~ fi) .  

    crl [Ask] : s[g] | A[ask s fi . P + P' | Q] => {A : ask s fi} s[g] | A[P | Q] if g |- fi . 

    ***crl [Fuse] : < (x,uVec) (S | {x c}A) , n > => {ctx} < (s)(s[c] | S{s / x}) , n + 1 > if s := freshName (n) .
    crl [Fuse] : (x,uVec) (S | {x c}A) => {ctx} (s , uVec)(s[c] | S{s / x}) if s := fresh(0 , S) .

    rl [If-true] : A[(if e then P else Q') | Q] => {A :if} A[P | Q] .

    rl [If-false] : A[(if e then P else Q') | Q] => {A :if} A[Q' | Q] .

    ***semantica senza etichette
    sort TSystem .    
    op <_> : System -> TSystem [ctor frozen] .

    crl < S > => < S' > if S => {mu} S' .

    ***semantica A-solo senza do su s e if
    op prefCheck : Prefix SessionName -> Bool .
    eq prefCheck (do s a , s) = false .
    eq prefCheck (pi , s) = true [owise] .

    sort ASystem .
    op <_>_ : LSystem SessionName -> ASystem [ctor frozen] .
    crl < S > s => < S' > s if S => {A : pi} S' /\ prefCheck (pi, s) . 

    op RDempty : SessionName System Module -> Bool .
    eq RDempty(s,S,M:Module) = metaSearch(M:Module,
    upTerm(S),
    '`{_`}_['l:ASLabel,'S':System],
    '_:_[upTerm(A),'do__[upTerm(s),'a:IOAction]] := 'l:ASLabel,
    '+,
    1,
    0
    ) == failure . *** [print "RDEmpty: " s " , " S] .

    op succIfempty : System Module -> Bool .
    eq succIfempty(S,M:Module) = metaSearch(M:Module,
    upTerm(S),
    '`{_`}_['l:ASLabel,'S':System],
    '_:if[upTerm(A)] := 'l:ASLabel,
    '+,
    1,
    0
    ) == failure .

    op _ in _ : System SysSet -> Bool .
    eq S in S , set = true .
    eq S in set = false [owise] .

    op ready-at : SessionName System Module Nat SysSet -> Bool .
    
    ceq ready-at(s,S,M:Module,s(n), set) = true if not S in set /\ not RDempty(s,S,M:Module) . ***[print "Rule 1: " s " , " S " , " n " , " set] .

    ceq ready-at(s,S,M:Module,s(n), set) = true if not S in set /\ metaSearch(M:Module,
    upTerm(< S > s),
    '<_>_['S':System , upTerm(s)],
    'ready-at[upTerm(s),'S':System,upTerm(M:Module),upTerm(n),'_`,_[upTerm(S),upTerm(set)]] = 'true.Bool,
    '+,
    1,
    0
    ) =/= failure . ***[print "Rule 2: " s " , " S " , " n " , " set] .
 
    ceq ready-at(s,S,M:Module,s(n),set) = true if not S in set /\ not succIfempty(S,M:Module) /\
    metaSearch(M:Module,
    upTerm(S),
    '`{_`}_['l:ASLabel,'S':System],
    '_:if[upTerm(A)] = 'l:ASLabel /\ 'ready-at[upTerm(s),'S':System,upTerm(M:Module),upTerm(n),'_`,_[upTerm(S),upTerm(set)]] = 'false.Bool,
    '+,
    1,
    0
    ) == failure . *** [print "Rule 3: " s " , " S " , " n " , " set] .
    
    eq ready-at(s,S,M:Module,n,set) = false [owise] . ***[owise print "Rule 4: " s " , " S " , " n " , " set] .

    ***eq ready(s,S,M:Module) =  metaSearch(M:Module,
    ***upTerm(< S > s),
    ***'<_>_['S:System , upTerm(s)],
    ***'S:System => '`{_`}_['l:ASLabel,'S':System] /\ '_:_[upTerm(A),'do__[upTerm(s),'a:Atom]] := 'l:ASLabel,
    ***'*,
    ***unbounded,
    ***0
    ***) =/= failure .

    

    op culp : RdyContract Module -> Bool .
    eq culp (g , M:Module) = metaSearch(M:Module,
    upTerm(g),
    '`{_`}_['l:ACLabel,'d:RdyContract],
    'a:IOAction := 'l:ACLabel,
    '+,
    1,
    0 
    ) =/= failure .

    op ready : System System Module Nat -> Bool .
    ceq ready(S , s[g] , M:Module , n) = ready-at(s , S' , M:Module,n,empty) if culp(g , M:Module) /\ (uVec) S' := S .
    ceq ready(S , s[g] , M:Module , n) = true if not culp(g , M:Module) .
    eq ready(S , s[g] , M:Module , n) = ready-at(s , S , M:Module,n,empty) [owise] . 
    ceq ready (S , S' | S'' , M:Module , n) = ready (S , S' , M:Module , n) and ready(S , S'' , M:Module , n) if S' =/= 0 /\ S'' =/= 0 .
    ceq ready (S , (uVec) S' , M:Module , n) = ready (S , S' , M:Module , n) if (uVec) =/= empty .
    eq ready (S , 0 , M:Module , n) = true .
    eq ready (S , B:Participant[P] , M:Module , n) = true .
    eq ready (S , {u c}B:Participant , M:Module , n) = true .

    op search-honest : Process Module Nat -> ResultTriple? .
    eq search-honest(P , M:Module , n) = metaSearch(M:Module,
    upTerm(< A[P] >),
    '<_>['S:System],
    'ready['S:System,'S:System, upTerm(M:Module), upTerm(n)] = 'false.Bool,
    '*,
    unbounded,
    0) .

    sort Result .
    subsort Result < TSystem .
    subsort Result < Bool .

    op honest : Process Module Nat -> Result .

    ceq honest (P , M:Module , n) = true if search-honest (P , M:Module , n) == failure .
    ceq honest (P , M:Module , n) = downTerm (T:Term , < (0).System > ) 
        if {T:Term , Ty:Type , S:Substitution} := search-honest (P , M:Module , n) . 

   ***Constants for testing
   op at : -> ActName .
   op T : -> BType .
   op expr : -> Expression .
    
endm
