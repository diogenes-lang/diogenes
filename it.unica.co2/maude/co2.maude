in contracts .

mod CO2-SYNTAX is
    protecting ASK .
    protecting COMPLIANCE .
    including NAT .
    including STRING .

    sorts System Process Prefix SessionName SessionVariable SessionIde GuardProc Sum IdeVec ProcIde ParamList Expression .
    subsort SessionName < SessionIde < IdeVec .
    subsort String < SessionVariable < SessionIde < IdeVec . 
    subsort GuardProc < Sum < Process .
    subsort SessionIde < ParamList .
    subsort Expression < ParamList .

    op empty : -> IdeVec [ctor] .
    op void : -> ParamList [ctor] .

    op 0 : -> System [ctor] .
    op 0 : -> Sum [ctor] .

    op t : -> Prefix [ctor] .

    op _;_ : ParamList ParamList -> ParamList [ctor assoc id: void prec 20] .
    op _,_ : IdeVec IdeVec -> IdeVec [comm assoc ctor id: empty] .

    op _[_] : Participant Process -> System [frozen ctor prec 20] .
    op _[_] : SessionName BiContract -> System [frozen ctor prec 20] .
    op _|_ : System System -> System [comm assoc frozen ctor id: 0 prec 35] .
    op (_)_ : IdeVec System -> System [frozen ctor prec 33] .
    op {__}_ : SessionIde UniContract Participant -> System [frozen ctor prec 20] .
    op _._ : Prefix Process -> GuardProc [frozen ctor prec 25] .
    op _+_ : Sum Sum -> Sum [comm assoc frozen ctor id: 0 prec 30] .
    op _|_ : Process Process -> Process [comm assoc frozen ctor id: 0 prec 35] .
    op (_)_ : IdeVec Process -> Process [frozen ctor prec 33] .
    op tell __ : SessionIde UniContract -> Prefix [frozen ctor prec 20] .
    op do __ : SessionIde IOAction -> Prefix [frozen ctor prec 20] .
    op ask __ : SessionIde Formula -> Prefix [frozen ctor prec 20] .
    op _(_) : ProcIde ParamList -> Process [frozen ctor prec 20] .
    op if _ then _ else _ : Expression Process Process -> Process [frozen ctor prec 36] .

    op $_ : Nat -> SessionName [ctor prec 20] .
    op __ : String Nat -> SessionVariable [ctor prec 20] .

    sorts Process? Env .
    subsort Process < Process? .

    vars u u' v : SessionIde .
    vars x x' : SessionVariable .
	vars uVec vVec : IdeVec .
    vars uList vList uList' vList' : ParamList .
	vars s s' : SessionName .
	var A : Participant .
	vars P Q Q' : Process .
	vars S S' : System .
	var g : BiContract .
	var pi : Prefix .
    var phi : Formula .
	vars M N : Sum .
	var a : IOAction .
	var c : UniContract .
    var n : Nat .
    vars X X' : ProcIde .
    vars E E' : Env .
    var q : String .
    vars e e' : Expression .

    op _(_)=def_ : ProcIde ParamList Process -> Env [frozen prec 40] .
    op emptyEnv : -> Env .
    op _&_ : Env Env -> Env [assoc comm id: emptyEnv prec 42] .
    op _definedIn_ : ProcIde Env -> Bool .
    op def : ProcIde Env -> Process? .
    op param : ProcIde Env -> ParamList .
    op not-defined : -> Process? .

    op env : -> Env .

    eq X definedIn emptyEnv = false .
    eq X definedIn (X' (uList) =def P & E) = (X == X') or (X definedIn E) .
    eq def(X, emptyEnv) = not-defined .
    eq def(X, (X' (uList) =def P) & E) = if X == X' then P else def(X, E) fi .
    eq param(X, (X' (uList) =def P) & E) = if X == X' then uList else param(X, E) fi .
    eq param(X, emptyEnv) = empty .

    ***substitution of free variables
    op _{_/_} : System SessionIde SessionIde -> System .
    op _{_/_} : Process SessionIde SessionIde -> Process .
    op _{_/_} : ParamList SessionIde SessionIde -> ParamList .

    eq u' ; uList {u / v} = if v == u' then u ; (uList{u / v}) else u' ;  (uList{u / v}) fi .
    eq e ; uList {u / v} = e ; (uList{u / v}) .
    eq void {u / v} = void .
    eq (0).Sum {u / v} = (0).Sum .
    eq t . P {u / v} = t . (P {u / v}) .
    eq tell u' c . P {u / v} = if v == u' then tell u c . (P {u / v}) else tell u' c . (P {u / v}) fi .
    eq ask u' phi . P {u / v} = if v == u' then ask u phi . (P {u / v}) else ask u' phi . (P {u / v}) fi .
    eq do u' a . P {u / v} = if v == u' then do u a . (P{u / v}) else do u' a . (P {u / v}) fi .
    ceq M + N {u / v} = (M {u / v}) + (N {u / v}) if M =/= 0 /\ N =/= 0 .
    ceq P | Q {u / v} = (P {u / v}) | (Q {u / v}) if P =/= 0 /\ Q =/= 0 .
    eq (if e then P else Q){u / v} = if e then (P{u / v}) else (Q{u / v}) .
    eq (v , uVec) P {u / v} = (v , (uVec{u / v})) P .
    eq (uVec) P {u / v} = (uVec) (P {u / v}) [owise] . 
    eq {u' c}A {u / v} = if v == u' then {u c}A else {u' c}A fi .
    eq A[P] {u / v} = A[P {u / v}] .
    eq s[g] {s' / v} = if s == v then s'[g] else s[g] fi .
    eq s[g] {x / v} = s[g] . 
    eq X(uList) {u / v} = X(uList{u / v}) .
    ceq S | S' {u / v} = (S{u / v}) | (S'{u / v}) if S =/= 0 /\ S' =/= 0 .
    eq (v , uVec) S {u / v} = (v , uVec) S .
    eq (uVec) S {u / v} = (uVec) (S {u / v}) [owise] . 

    op _ in _ : SessionIde IdeVec -> Bool .

    eq u in (u , uVec) = true . 
    eq u in uVec = false [owise] .

    op _ in _ : SessionIde ParamList -> Bool .

    eq u in void = false .
    eq u in (v ; uList) = if u == v then true else u in uList fi .     
    eq u in (e ; uList) = u in uList .

    op is _ free in _ : SessionIde System -> Bool .
    op is _ free in _ : SessionIde Process -> Bool .
    op is _ free in _ : SessionIde Prefix -> Bool .

    eq is u free in (uVec) S = (not u in uVec) and is u free in S . 
    eq is u free in (uVec) P = (not u in uVec) and is u free in P .  
	eq is u free in (0).System = false .
    eq is u free in (0).Process = false .
	eq is u free in A[P] = is u free in P .
	eq is u free in s[g] = u == s .
    eq is u free in {v c}A = u == v .
	ceq is u free in S | S' = is u free in S or is u free in S' if S =/= 0 and S' =/= 0 .
    ceq is u free in P | Q = is u free in P or is u free in Q if P =/= 0 and Q =/= 0 .
	ceq is u free in M + N = is u free in M or is u free in N if N =/= 0 and M =/= 0 .
    eq is u free in pi . P = is u free in pi or is u free in P .
   eq is u free in if e then P else Q = is u free in P or is u free in Q .
	eq is u free in do v a = u == v .
	eq is u free in t = false .
	eq is u free in tell v c = u == v .
    eq is u free in ask v phi = u == v .
    eq is u free in X(uList) = u in uList .

    op alpha : System System SessionIde -> SessionVariable .
    op alpha : Process Process SessionIde -> SessionVariable .
    
    eq alpha (S , S' , q n) = if not is (q n) free in S and not is (q n) free in S' then q n else alpha (S , S' , q (n + 1)) fi .
    eq alpha (S , S' , q) = alpha(S , S' , q 0) [owise] .
    eq alpha (P , Q , q n) = if not is (q n) free in P and not is (q n) free in Q then q n else alpha (P , Q , q (n + 1)) fi .
    eq alpha (P , Q , q) = alpha(P , Q , q 0) [owise] .
    eq alpha (S , S' , $ n) = if not is ($ n) free in S and not is ($ n) free in S' then $ n else alpha (S , S' , $ (n + 1)) fi .
    eq alpha (P , Q , $ n) = if not is ($ n) free in P and not is ($ n) free in Q then $ n else alpha (P , Q , $ (n + 1)) fi .

    ***structural equivalence. Equations are not commutative
    eq (u , u) = u .
	ceq S | ((u,uVec)S') = ((u)(S | (uVec)S')) if S =/= 0 /\ not is u free in S .
    ceq S | ((u,uVec)S') = (v)(S | (((uVec) S'){v / u})) if S =/= 0 /\ v := alpha(S , S' , u) [owise] .
	ceq P | ((u,uVec)Q) = ((u)(P | (uVec)Q)) if P =/= 0 /\ not is u free in P .
    ceq P | ((u,uVec)Q) = (v)(P | (((uVec) Q){v / u})) if P =/= 0 /\ v := alpha(P , Q , u) [owise] .
   ceq if e then P else ((u,uVec)Q) = (u) (if e then P else ((uVec)Q)) if not is u free in P .
    ceq if e then P else ((u,uVec)Q) = (v) (if e then P else (((uVec)Q){v / u})) if v := alpha(P , Q , u) [owise] .
	***ceq ((u)S) = S if not is u free in S .
	ceq ((u,uVec)S) = (uVec) S if not is u free in (uVec)S .
    ***ceq ((u)P) = P if not is u free in P .
	ceq ((u,uVec)P) = (uVec) P if not is u free in (uVec)P .
	eq {s c}A = 0 .
	eq A[(uVec)P] = (uVec)(A[P]) .
	eq ((uVec)(vVec) S) = ((uVec , vVec) S) .
	eq ((uVec)(vVec) P) = ((uVec , vVec) P) .
    eq (empty) S = S .
    eq (empty) P = P .
    ceq A[X(uList) | P] = A[(def(X,env){uList / param(X,env)}) | P] if X definedIn env .
   eq (if e then P else Q){u / v} = if e then (P{u / v}) else (Q{u / v}) .

    sort ParamListPair .
    op (_&_) : ParamList ParamList -> ParamListPair .

    op _-_ : ParamListPair SessionIde -> ParamListPair .

    eq (u ; uList & v ; vList) - v = (uList & vList) .
    eq (e ; uList & e' ; vList) - v = (uList & vList) - v .
    eq (void & void) - v = (void & void) .
    ceq (u ; uList & v ; vList) - u' = (u ; uList' & v ; vList') if (uList' & vList') := (uList & vList) - u' [owise] .

    op _{_/_} : Process ParamList ParamList -> Process .
    op _{_/_} : SessionIde ParamList ParamList -> SessionIde . 
    op _{_/_} : ParamList ParamList ParamList -> ParamList .

    eq u{u' ; uList / x ; vList} = if u == x then u' else u{uList / vList} fi .
    eq u{e ; uList / e' ; vList} = u{uList / vList} .
    eq u{void / void} = u .

    eq u ; uList'{uList / vList} = (u{uList / vList}) ; (uList'{uList / vList}) .
    eq e ; uList'{uList / vList} = e ; (uList'{uList / vList}) .
    eq void {uList / vList} = void .
    
    eq (0).Sum {uList / vList} = 0 .
    eq t . P {uList / vList} = t . (P{uList / vList}) .
    eq do u a . P {uList / vList} = do (u {uList / vList}) a . (P{uList / vList}) .
    eq ask u phi . P {uList / vList} = ask (u {uList / vList}) phi . (P{uList / vList}) .
    eq tell u c . P {uList / vList} = tell (u {uList / vList}) c . (P{uList / vList}) .
    ceq N + M {uList / vList} = (N{uList / vList}) + (M{uList / vList}) if N =/= 0 /\ M =/= 0 .
    ceq P | Q {uList / vList} = (P{uList / vList}) | (Q{uList / vList}) if P =/= 0 /\ Q =/= 0 .
    ceq (u , uVec) P {uList / vList} = (u)Q if (uList' & vList') := (uList & vList) - u /\ Q := (uVec) P {uList' / vList'} .
    eq X(uList'){uList / vList} = X(uList'{uList / vList}) .
    eq (if e then P else Q) {uList / vList} = if e then (P{uList / vList}) else (Q{uList / vList}) .

endm

***red (A[t . X('x ; 'x') | do 'x a . 0] | ($ 0) $ 0[g]) {$ 0 / 'x} .
***parse ($ 0) ; $ 1 .

mod CO2-SEM is
    protecting CO2-SYNTAX .
    protecting COMPLIANCE .
    protecting CULPABILITY .
    including META-LEVEL .

    sorts LSystem SLabel LPrefix .
    sort SysSet .

    subsort System < SysSet .
    subsort System < LSystem .
    subsort Prefix < LPrefix .

    op empty : -> SysSet .
    op _,_ : SysSet SysSet -> SysSet [comm assoc frozen] .

    op fuse : -> LPrefix .

    op _:_ : Participant LPrefix -> SLabel [ctor] .
    op _:if : Participant -> SLabel [ctor] .

    op {_}_ : SLabel System -> LSystem [frozen ctor] .

    op Z : -> Participant .

    vars A B : Participant .
    vars P Q P' R : Process .
    var u : SessionIde .
    vars c d : UniContract .
    vars s s' : SessionName .
    vars g g' : BiContract .
    var a : IOAction .
    var pi : LPrefix .
    vars uVec vVec : IdeVec .
    vars S S' S'' : System .
    vars x y : SessionVariable .
    var n : Nat .
    var phi : Formula .
    var X : ProcIde .
    var uList : ParamList .
    vars l l' : SLabel .
    var e : Expression .
    var set : SysSet .

    op del : IdeVec Prefix -> Prefix .
    eq del((u , uVec) , do u a) = t .
    eq del((u , uVec) , tell u c) = t .
    eq del((u , uVec) , ask u phi) = t .
***    eq del((u , uVec) , ask2 u phi) = t .
    eq del(uVec , pi) = pi [owise] .

    op fresh : Nat System -> SessionName .
    eq fresh(n , S) = if not is $ n free in S then $ n else fresh(n + 1 , S) fi .

    rl [Tau] : A[t . P + P' | Q] => {A : t} A[P | Q] .

    rl [Tell] : A[tell u c . P + P' | Q] => {A : tell u c} A[P | Q] | {u c} A .

    crl [Do] : A[do s a . P + P' | Q] | s[g] => {A : do s a} (A[P | Q] | s[g']) if g => {A says a} g' .

    ***crl [Del] : (u , uVec) S => {A : del(u,pi)}(u) S' if (uVec) S => {A : pi} S' .
    crl [Del] : (uVec) S => {A : del(uVec , pi)}(uVec) S' if S => {A : pi} S' .

    crl [Par] : S | S'' => {l} S' | S'' if S =/= 0 /\ S'' =/= 0 /\ S => {l} S' .

    crl [Fuse] : (uVec , vVec) ({x c}A | {y d}B | S) => {Z : fuse}(s , vVec)(s[A says c | B says d] | S{s / x}{s / y}) if
        uVec == (x , y) /\ c |X| d /\ s := fresh(0 , S) .

    crl [Ask] : A[ask s phi . P + P' | Q] | s[g] => {A : ask s phi} A[P | Q] if g |- phi .

    rl [If-true] : A[(if e then P else P') | Q] => {A :if} A[P | Q] .

    rl [If-false] : A[(if e then P else P') | Q] => {A :if} A[P' | Q] .

    *** blocking Ask (say, askb) could be encoded as follows:
    *** [askb s phi . P] = X, where X =def ask s phi . P : X
    *** Reverse encoding:
    *** [ask s phi . P : R] = ask s phi . P + ask s ~phi R
    *** ex: ask x <>payH . (ask y <>payF . do z commit : ???) : (???)

    ***crl [Def] : A[X (uList) | Q] | S => {A : pi} S' if (X definedIn env) /\ 
    ***    A[(def(X,env){uList / param(X,env)}) | Q] | S => {A : pi} S' .

    sort TSystem .

    op <_> : System -> TSystem [frozen] .
    ***op dummyS : -> SLabel [ctor] .
    
    ***eq [S] = [{dummyS}S] .
    
    crl [Rifl] : < S > => < S' > if S => {l'} S' .

    sort ASystem .

    op prefCheck : Prefix SessionName -> Bool .
    eq prefCheck (do s a , s) = false .
    eq prefCheck (pi , s) = true [owise] .

    op <_>__ : System Participant SessionName -> ASystem . 

    *** non A-solo semantics: =/= A: do s 
    *** crl < S > A s => < S' > A s if S => {B : pi} S' /\ (B =/= A or prefCheck(pi , s)) .

    *** A-solo semantics: A: =/= {do s , if}
    crl < S > A s => < S' > A s if S => {A : pi} S' /\ prefCheck(pi , s) .

    op RDempty : Participant SessionName System Module -> Bool .
    eq RDempty(A,s,S,M:Module) = metaSearch(M:Module,
    upTerm(S),
    '`{_`}_['l:SLabel,'S':System],
    '_:_[upTerm(A) ,'do__[upTerm(s),'a:IOAction]] := 'l:SLabel,
    '+,
    1,
    0
    ) == failure .

    op succIfempty : Participant System Module -> Bool .
    eq succIfempty(A,S,M:Module) = metaSearch(M:Module,
    upTerm(S),
    '`{_`}_['l:SLabel,'S':System],
    '_:if[upTerm(A)] := 'l:SLabel,
    '+,
    1,
    0
    ) == failure .

    op _ in _ : System SysSet -> Bool .
    eq S in S , set = true .
    eq S in set = false [owise] .

    op ready : Participant SessionName System Module Nat SysSet -> Bool .
    
    ceq ready(A,s,S,M:Module,s(n), set) = true if not S in set /\ not RDempty(A,s,S,M:Module) [print "Rule 1: " A " , " s " , " S " , " n " , " set] .

    ceq ready(A,s,S,M:Module,s(n), set) = true if not S in set /\ metaSearch(M:Module,
    upTerm(< S > A s),
    '<_>__['S':System , upTerm(A) , upTerm(s)],
    'ready[upTerm(A),upTerm(s),'S':System,upTerm(M:Module),upTerm(n),'_`,_[upTerm(S),upTerm(set)]] = 'true.Bool,
    '+,
    1,
    0
    ) =/= failure [print "Rule 2: " A " , " s " , " S " , " n " , " set] .

    ceq ready(A,s,S,M:Module,s(n),set) = true if not S in set /\ not succIfempty(A,S,M:Module) /\
    metaSearch(M:Module,
    upTerm(S),
    '`{_`}_['l:SLabel,'S':System],
    upTerm(A :if) = 'l:SLabel /\ 'ready[upTerm(A) , upTerm(s),'S':System,upTerm(M:Module),upTerm(n),'_`,_[upTerm(S),upTerm(set)]] = 'false.Bool,
    '+,
    1,
    0
    ) == failure [print "Rule 3: " A " , " s " , " S " , " n " , " set] .
    
    eq ready(A,s,S,M:Module,n,set) = false [owise print "Rule 4: " A " , " s " , " S " , " n " , " set] .

    ***op ready : Participant SessionName System Module -> Bool .
    ***eq ready(A,s,S,M:Module) =  metaSearch(M:Module,
    ***upTerm(< S > A s),
    ***'<_>__['S:System , upTerm(A) , upTerm(s)],
    ***'S:System => '`{_`}_['l:SLabel,'S':System] /\ '_:_[upTerm(A),'do__[upTerm(s),'a:Atom]] := 'l:SLabel,
    ***'*,
    ***unbounded,
    ***0
    ***) =/= failure .

    op ready : Participant System System Module Nat -> Bool .
    ceq ready(A , S , s[g] , M:Module, n) = ready(A , s , S' , M:Module , n , empty) if A :C g /\ (uVec) S' := S .
    ceq ready(A , S , s[g] , M:Module, n) = true if not A :C g .
    eq ready(A , S , s[g] , M:Module, n) = ready(A , s , S , M:Module , n , empty) [owise] . 
    ceq ready (A , S , S' | S'' , M:Module, n) = ready (A , S , S' , M:Module, n) and ready(A , S , S'' , M:Module, n) if S' =/= 0 /\ S'' =/= 0 .
    ceq ready (A , S , (uVec) S' , M:Module, n) = ready (A , S , S' , M:Module, n) if (uVec) =/= empty .
    eq ready (A , S , 0 , M:Module, n) = true .
    eq ready (A , S , B:Participant[P] , M:Module, n) = true .
    eq ready (A , S , {u c}B:Participant , M:Module, n) = true .

    op search-honest-ctx : Participant System Module Nat -> ResultTriple? .
    eq search-honest-ctx(A , S , M:Module , n) = metaSearch(M:Module,
    upTerm(< S >),
    '<_>['S:System],
    'ready[upTerm(A) , 'S:System,'S:System, upTerm(M:Module) , upTerm(n)] = 'false.Bool,
    '*,
    unbounded,
    0) .

    sort Result .
    subsort Result < TSystem .
    subsort Result < Bool .

    op honest-ctx : Participant System Module Nat -> Result .

    ceq honest-ctx (A , S , M:Module , n) = true if search-honest-ctx (A , S , M:Module , n) == failure .
    ceq honest-ctx (A , S , M:Module , n) = downTerm (T:Term , < (0).System > ) 
        if {T:Term , Ty:Type , S:Substitution} := search-honest-ctx (A , S , M:Module , n) . 
   
   ***Constants for testing
   ***ops A B : -> Participant .
   op at : -> ActName .
   op T : -> BType .
   op expr : -> Expression .

endm

parse Al[if expr then do ($ 0) (at ? T) . 0 else t . do ($ 0) (at ! T) . 0] | $ 0 [Al says ready (at ? T) . 0 | Bo says 0] .
red upTerm(Al[if expr then do ($ 0) (at ? T) . 0 else t . do ($ 0) (at ! T) . 0] | $ 0 [Al says ready (at ? T) . 0 | Bo says 0]) .

set print attribute on .
red ready(Al , $ 0 , Al[if expr then do ($ 0) (at ? T) . 0 else t . do ($ 0) (at ? T) . 0] | $ 0 [Al says ready (at ? T) . 0 | Bo says 0] , ['CO2-SEM] , 10 , empty) .
set print attribute off .

*** red succIfempty(Al , Al[if expr then do ($ 0) (at ? T) . 0 else t . do ($ 0) (at ! T) . 0] | $ 0 [Al says ready (at ? T) . 0 | Bo says 0] , ['CO2-SEM]) .

***set trace on .
***rew Al[if expr then do ($ 0) (at ? T) . 0 else t . do ($ 0) (at ! T) . 0] | $ 0 [Al says ready (at ? T) . 0 | Bo says 0]  . *** | $ 0 [Al says ready (at ? T) . 0 | Bo says 0] .
***set trace off .

***search A[if e then do ($ 0) (at:ActName ? T:BType) . 0 else t . do ($ 0) (at:ActName ! T:BType) . 0] | $ 0 [A says ready (at:ActName ? T:BType) . 0 | B says 0] =>1 {A : (do ($ 0) a:IOAction)}S' .

