/*
 * generated by Xtext
 */
package it.unica.co2.validation

import it.unica.co2.contracts.ContractDefinition
import it.unica.co2.contracts.ContractsPackage
import it.unica.co2.contracts.EmptyContract
import it.unica.co2.contracts.ExtAction
import it.unica.co2.contracts.ExtSum
import it.unica.co2.contracts.IntAction
import it.unica.co2.contracts.IntSum
import it.unica.co2.contracts.Recursion
import it.unica.co2.contracts.UnitType
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ContractsValidator extends AbstractContractsValidator {

	@Check
	def void checkContractNameIsUnique(ContractDefinition contractDef) {
		var root = EcoreUtil2.getRootContainer(contractDef);
		for (other: EcoreUtil2.getAllContentsOfType(root, ContractDefinition)){
			
			if (contractDef!=other && contractDef.getName.equals(other.name)) {
				error("Contract names have to be unique", 
					ContractsPackage.Literals.CONTRACT_DEFINITION__NAME
				);
				return;
			}
		}
	}
	
	@Check
	def void checkInternalActionsName(IntAction internalAction) {
		
		if (internalAction.eContainer instanceof IntSum)
			for (other: (internalAction.eContainer() as IntSum).actions){
				
				if (internalAction!=other && internalAction.actionName.equals(other.actionName)) {
					error("Action names have to be unique", 
						ContractsPackage.Literals.INT_ACTION__ACTION_NAME
					);
					return;
				}
			}
	}
	
	@Check
	def void checkExternalActionsName(ExtAction externalAction) {
		
		if (externalAction.eContainer instanceof ExtSum)
			for (other: (externalAction.eContainer() as ExtSum).actions){
				
				if (externalAction!=other && externalAction.actionName.equals(other.actionName)) {
					error("Action names have to be unique", 
						ContractsPackage.Literals.EXT_ACTION__ACTION_NAME
					);
					return;
				}
			}
	}
	
	@Check
	def void checkUnitTypeInt(IntAction action) {
		if (action.type!=null && action.type.equals("unit"))
			info("Unit type can be omitted", 
				ContractsPackage.Literals.INT_ACTION__TYPE
			);
	}
	
	@Check
	def void checkUnitTypeExt(ExtAction action) {
		if (action.type!=null && action.type.equals("unit"))
			info("Unit type can be omitted", 
				ContractsPackage.Literals.EXT_ACTION__TYPE
			);
	}
	
	@Check
	def void checkExtActionType(ExtAction action) {
		if (action.type!=null && action.type instanceof UnitType)
			info('Unit type can be omitted', ContractsPackage.Literals.EXT_ACTION__TYPE)
	}
	
	@Check
	def void checkIntActionType(IntAction action) {
		if (action.type!=null && action.type instanceof UnitType)
			info('Unit type can be omitted', ContractsPackage.Literals.INT_ACTION__TYPE)
	}
	
	@Check
	def void checkEmptyContract(EmptyContract empty) {
		
		info("Empty contract can be omitted", 
			ContractsPackage.Literals.EMPTY_CONTRACT__VALUE
		);
	}
	
	@Check
	def void checkRecursionDefinition(Recursion recursion) {
		this.checkRecursionID(recursion.eContainer, recursion.name)
	}
	
	def dispatch void checkRecursionID(EObject obj, String name) {
    	checkRecursionID(obj.eContainer, name)
    }
    
    def dispatch void checkRecursionID(Recursion obj, String name) {
    	if (obj.name.equals(name)) {
    		warning("You are hiding an existing name",
    			ContractsPackage.Literals.RECURSION__NAME
    		)
    	}
    	checkRecursionID(obj.eContainer, name)
    }
    
    def dispatch void checkRecursionID(ContractDefinition obj, String name) {
    	// stop recursion
    }
}
