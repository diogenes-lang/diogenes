/*
 * generated by Xtext
 */
package it.unica.co2.scoping

import com.google.common.base.Predicate
import it.unica.co2.co2.ContractDefinition
import it.unica.co2.co2.ContractReference
import it.unica.co2.co2.DelimitedProcess
import it.unica.co2.co2.DoInput
import it.unica.co2.co2.ProcessDefinition
import it.unica.co2.co2.Recursion
import it.unica.co2.co2.Tell
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.scoping.impl.FilteringScope

import static extension it.unica.co2.utils.CustomExtensions.*

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class CO2ScopeProvider extends AbstractDeclarativeScopeProvider {

	/*
	 * Contract reference:
	 * refers to any contract definition except for this
	 */
	def IScope scope_Tell_contractReference(Tell ctx, EReference ref) {
		ctx.getIScopeForAllContentsOfClass(ContractDefinition);
	}
	
	
	/*
	 * FreeName reference
	 */
	def IScope scope_FreeName(EObject ctx, EReference ref) {
		return getDeclaredFreeNames(ctx.eContainer);
	}

	/*
	 * utils: recursively get all free-names declarations until ProcessDefinition
	 */
	def dispatch IScope getDeclaredFreeNames(EObject cont) {
		return getDeclaredFreeNames(cont.eContainer);
	}
	
	def dispatch IScope getDeclaredFreeNames(DelimitedProcess proc) {
		return Scopes.scopeFor(
			proc.freeNames
			,
			getDeclaredFreeNames(proc.eContainer) // outer
		);
	}
	
	def dispatch IScope getDeclaredFreeNames(DoInput proc) {
		if (proc.variable==null)
			return getDeclaredFreeNames(proc.eContainer)
		else
			return Scopes.scopeFor(
				newArrayList(proc.variable)
				,
				getDeclaredFreeNames(proc.eContainer) // outer
			);
	}

	def dispatch IScope getDeclaredFreeNames(ProcessDefinition obj) {
		return Scopes.scopeFor(obj.params); // stop recursion
	}
	
	
	
	
	/*
	 * Scope for Referrable, alias [Recursion] or [ContractDefinition]
	 */
	def IScope scope_Referrable(ContractReference ctx, EReference ref) {
		Scopes.scopeFor(
			scope_ContractDefinition(ctx, ref).allElements.map[x|x.EObjectOrProxy],
			scope_Recursion(ctx, ref)
		)
	}

	/*
	 * Recursion reference: 
	 * refers only to recursions defined before ctx but into the same contract definition
	 */
	def IScope scope_Recursion(ContractReference ctx, EReference ref) {
		return definedRecursions(ctx.eContainer);
	}

	/*
	 * utils: recursively bind all rec definition until ContractDefinition is reached
	 */
	def dispatch IScope definedRecursions(EObject cont) {
		return definedRecursions(cont.eContainer);
	}

	def dispatch IScope definedRecursions(Recursion rec) {
		return Scopes.scopeFor(
			newArrayList(rec)
			,
			definedRecursions(rec.eContainer) // outer
		);
	}

	def dispatch IScope definedRecursions(ContractDefinition obj) {
		return IScope.NULLSCOPE; // stop recursion
	}



	/*
	 * Contract reference:
	 * refers to any contract definition except for this
	 */
	def IScope scope_ContractDefinition(ContractReference ctx, EReference ref) {
		var scope = ctx.getIScopeForAllContentsOfClass(ContractDefinition);
		val contractDef = ctx.getFirstUpOccurrenceOf(ContractDefinition)

		new FilteringScope(scope, new Predicate<IEObjectDescription>() {

			override apply(IEObjectDescription input) {
				return input.getEObjectOrProxy() != contractDef;
			}

		});
	}
	
	/*
	 * Process reference: refers to any process
	 */
	def IScope scope_ProcessDefinition(EObject ctx, EReference ref) {
		return ctx.getIScopeForAllContentsOfClass(ProcessDefinition);
	}

}
