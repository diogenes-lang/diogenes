/*
 * generated by Xtext
 */
package it.unica.co2.scoping

import it.unica.co2.co2.ContractDefinition
import it.unica.co2.co2.ContractReference
import it.unica.co2.co2.DelimitedProcess
import it.unica.co2.co2.DoInput
import it.unica.co2.co2.Input
import it.unica.co2.co2.ProcessDefinition
import it.unica.co2.co2.TellAndWait
import it.unica.co2.co2.TellRetract
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider

import static extension it.unica.co2.utils.CustomExtensions.*

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class CO2ScopeProvider extends AbstractDeclarativeScopeProvider {

	/*
	 * Contract reference:
	 * refers to any contract definition except for this
	 */
	def IScope scope_ContractDefinition(EObject ctx, EReference ref) {
		ctx.getIScopeForAllContentsOfClass(ContractDefinition);
	}
	
	
	/*
	 * FreeName reference
	 */
	def IScope scope_Referrable(EObject ctx, EReference ref) {
		return getDeclaredVariables(ctx.eContainer);
	}

	/*
	 * utils: recursively get all free-names declarations until ProcessDefinition
	 */
	def dispatch IScope getDeclaredVariables(EObject cont) {
		return getDeclaredVariables(cont.eContainer);
	}
	
	def dispatch IScope getDeclaredVariables(DelimitedProcess proc) {
		return Scopes.scopeFor(
			proc.freeNames
			,
			getDeclaredVariables(proc.eContainer) // outer
		);
	}
	
	def dispatch IScope getDeclaredVariables(DoInput proc) {
		if (proc.variable==null)
			return getDeclaredVariables(proc.eContainer)
		else
			return Scopes.scopeFor(
				newArrayList(proc.variable)
				,
				getDeclaredVariables(proc.eContainer) // outer
			);
	}
	
	def dispatch IScope getDeclaredVariables(Input proc) {
		if (proc.variable==null)
			return getDeclaredVariables(proc.eContainer)
		else
			return Scopes.scopeFor(
				newArrayList(proc.variable)
				,
				getDeclaredVariables(proc.eContainer) // outer
			);
	}
	
	def dispatch IScope getDeclaredVariables(TellRetract proc) {
		return Scopes.scopeFor(
			newArrayList(proc.session)
			,
			getDeclaredVariables(proc.eContainer) // outer
		);
	}

	def dispatch IScope getDeclaredVariables(TellAndWait proc) {
		return Scopes.scopeFor(
			newArrayList(proc.session)
			,
			getDeclaredVariables(proc.eContainer) // outer
		);
	}

	def dispatch IScope getDeclaredVariables(ProcessDefinition obj) {
		return Scopes.scopeFor(obj.params); // stop recursion
	}
	
	
	
	
	/*
	 * Scope for Referrable, alias [Recursion] or [ContractDefinition]
	 */
	def IScope scope_Referrable(ContractReference ctx, EReference ref) {
		Scopes.scopeFor(
			scope_ContractDefinition(ctx, ref).allElements.map[x|x.EObjectOrProxy]
//			,
//			scope_Recursion(ctx, ref)
		)
	}

	/*
	 * Recursion reference: 
	 * refers only to recursions defined before ctx but into the same contract definition
	 */
//	def IScope scope_Recursion(ContractReference ctx, EReference ref) {
//		return definedRecursions(ctx.eContainer);
//	}
//
//	/*
//	 * utils: recursively bind all rec definition until ContractDefinition is reached
//	 */
//	def dispatch IScope definedRecursions(EObject cont) {
//		return definedRecursions(cont.eContainer);
//	}
//
//	def dispatch IScope definedRecursions(Recursion rec) {
//		return Scopes.scopeFor(
//			newArrayList(rec)
//			,
//			definedRecursions(rec.eContainer) // outer
//		);
//	}
//
//	def dispatch IScope definedRecursions(ContractDefinition obj) {
//		return IScope.NULLSCOPE; // stop recursion
//	}



	/*
	 * Contract reference:
	 * refers to any contract definition except for this
	 */
	def IScope scope_ContractDefinition(ContractReference ctx, EReference ref) {
		var scope = ctx.getIScopeForAllContentsOfClass(ContractDefinition);
//		val contractDef = ctx.getFirstUpOccurrenceOf(ContractDefinition)
//
//		new FilteringScope(scope, new Predicate<IEObjectDescription>() {
//
//			override apply(IEObjectDescription input) {
//				return input.getEObjectOrProxy() != contractDef;
//			}
//
//		});
		
		return scope;
	}
	
	/*
	 * Process reference: refers to any process
	 */
	def IScope scope_ProcessDefinition(EObject ctx, EReference ref) {
		return ctx.getIScopeForAllContentsOfClass(ProcessDefinition);
	}

}
