package it.unica.co2.generator

import com.google.inject.Inject
import it.unica.co2.co2.ActionType
import it.unica.co2.co2.BooleanType
import it.unica.co2.co2.CO2System
import it.unica.co2.co2.Co2Factory
import it.unica.co2.co2.Contract
import it.unica.co2.co2.ContractDefinition
import it.unica.co2.co2.ContractReference
import it.unica.co2.co2.EmptyContract
import it.unica.co2.co2.ExtAction
import it.unica.co2.co2.ExtSum
import it.unica.co2.co2.FreeName
import it.unica.co2.co2.IntAction
import it.unica.co2.co2.IntActionType
import it.unica.co2.co2.IntSum
import it.unica.co2.co2.IntType
import it.unica.co2.co2.ProcessDefinition
import it.unica.co2.co2.Recursion
import it.unica.co2.co2.SessionType
import it.unica.co2.co2.StringActionType
import it.unica.co2.co2.StringType
import it.unica.co2.co2.Tell
import it.unica.co2.co2.UnitActionType
import java.text.SimpleDateFormat
import java.util.Date
import java.util.HashMap
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.naming.IQualifiedNameProvider

class JavaGenerator extends AbstractIGenerator {
	
	@Inject extension IQualifiedNameProvider qNameProvider
	
	int WAIT_TIMEOUT = 10000
	
	override doGenerate(Resource resource, IFileSystemAccess fsa) {
		
		for (e : resource.allContents.toIterable.filter(CO2System)) {
			var outputFilename = e.systemDeclaration.fullyQualifiedName.toString("/") + ".java"
			println('''generating «outputFilename»''')
			fsa.generateFile(outputFilename, e.generateJava)
		}
	}
	
	
	
	def String generateJava(CO2System co2System) {
		var className = co2System.systemDeclaration.fullyQualifiedName.lastSegment
		var packageName = co2System.systemDeclaration.fullyQualifiedName.skipLast(1)
		var processDefinitions = co2System.contractsAndProcessesDeclaration.processes
		var contractDefinitions = co2System.contractsAndProcessesDeclaration.contracts
		var honestyProcess = if (co2System.honesty!=null) co2System.honesty.process else null
		
		//fix recursion name
		contractDefinitions.fixRecursions()
		
		//fix anonymous tells
		contractDefinitions.addAll( co2System.eAllContents.filter(Tell).map[t| t.fixTell("_tell_contr_")].toSet )
		
		'''
		«IF !packageName.empty»
		package «packageName»;
		«ENDIF»
		
		import static it.unica.co2.model.ContractFactory.*;
		import it.unica.co2.api.Session2;
		import it.unica.co2.model.contract.Contract;
		import it.unica.co2.model.contract.ContractWrapper;
		import it.unica.co2.model.contract.Recursion;
		import it.unica.co2.model.contract.Sort;
		import it.unica.co2.model.process.CO2Process;
		import it.unica.co2.model.process.Participant;
		import co2api.ContractException;
		import co2api.Message;
		import co2api.Public;
		import co2api.TST;
		import co2api.TimeExpiredException;
		
		/*
		 * auto-generated by co2-plugin
		 * creation date: «new SimpleDateFormat("dd-MM-yyyy HH:mm:ss").format(new Date())»
		 */
		
		@SuppressWarnings("unused")
		public class «className» {
			«contractDefinitions.getJavaContractDeclarations»
			«contractDefinitions.getJavaContractDefinitions»
			«FOR p : processDefinitions»
			«p.getJavaClass»
			«ENDFOR»
			
			public static void main(String[] args) {
				«IF honestyProcess!=null»
				new «honestyProcess.name»().run();
				«ENDIF»
			}
		}
		'''
	}
	
	def String getJavaContractDeclarations(Iterable<ContractDefinition> contracts) {
		'''
		«IF contracts.size>0»
		
		/*
		 * contracts declaration
		 */
		«FOR c : contracts»
			«c.javaContractDeclaration»
			«c.javaRecursionContractDeclaration»
			«ENDFOR»
		«ENDIF»
		'''
	}
	
	def String getJavaContractDefinitions(Iterable<ContractDefinition> contracts) {
		'''
		«IF contracts.size>0»
		
		/*
		 * contracts initialization
		 */
		static {
			«FOR c : contracts»
			«c.javaContractDefinition»
			«c.javaRecursionContractDefinition»
			«ENDFOR»
		«ENDIF»
		}
		'''
	}
	
	def String getJavaContractDeclaration(ContractDefinition c) {
		'''private static ContractWrapper «c.name» = wrapper();'''
	}

	def String getJavaRecursionContractDeclaration(ContractDefinition c) {
		var recursions = c.eAllContents.filter(Recursion).toSet
		'''
		«FOR r : recursions»
		private static Recursion «r.name» = recursion();
		«ENDFOR»
		'''
	}
	
	def String getJavaContractDefinition(ContractDefinition c) {
		c.contract = c.contract?: Co2Factory.eINSTANCE.createEmptyContract
		'''«c.name».setContract(«c.contract.javaContract»);'''
	}
	
	def String getJavaRecursionContractDefinition(ContractDefinition c) {
		var recursions = c.eAllContents.filter(Recursion).toSet
		'''
		«FOR r : recursions»
		«r.name».setContract(«r.body.javaContract»);
		«ENDFOR»
		'''
	}
	
	def dispatch String getJavaContract(Contract c) {
		if (c.next!=null) c.next.javaContract else ""
	}
	
	def dispatch String getJavaContract(IntSum c) {
		'''internalSum()«FOR a : c.actions»«a.getJavaIntAction»«ENDFOR»'''
	}
	
	def dispatch String getJavaContract(ExtSum c) {
		'''externalSum()«FOR a : c.actions»«a.getJavaExtAction»«ENDFOR»'''
	}
	
	def dispatch String getJavaContract(ContractReference c) {
		c.ref.name
	}
	
	def dispatch String getJavaContract(Recursion c) {
		c.body.javaContract
	}
	
	def dispatch String getJavaContract(EmptyContract c) {
		'''null'''
	}
	
	def String getJavaIntAction(IntAction a) {
		'''.add("«a.actionName»", «a.type.javaActionSort»«IF a.next!=null», «a.next.javaContract»«ENDIF»)'''
	}
	
	def String getJavaExtAction(ExtAction a) {
		'''.add("«a.actionName»", «a.type.javaActionSort»«IF a.next!=null», «a.next.javaContract»«ENDIF»)'''
	}
	
	def String getJavaActionSort(ActionType type) {
		if (type==null || type instanceof UnitActionType) "Sort.UNIT"
		else if (type instanceof IntActionType) "Sort.INT"
		else if (type instanceof StringActionType) "Sort.STRING"
	}
	
	def String getJavaClass(ProcessDefinition p) {
		var className = p.name
		var hasFreeName = !p.params.empty
		'''
		
		private static class «className» extends «IF hasFreeName»CO2Process«ELSE»Participant«ENDIF» {
			private static final long serialVersionUID = 1L;
			«IF !hasFreeName»
			private static String username = "test@co2-plugin.com";
			private static String password = "test";
			«ENDIF»
			«p.getFieldsAndConstructor»
			
			@Override
			public void run() {
				
			}
		}
		'''
	}
	
	
	def String getFieldsAndConstructor(ProcessDefinition p) {
		
		'''
		«FOR fn : p.params»
		private «fn.javaType» «fn.name»;
		«ENDFOR»
		
		public «p.name»(«p.params.join(",", [fn | fn.javaType+" "+fn.name])») {
			«IF p.params.empty»
			super(username, password);
			«ELSE»
			super("«p.name»");
			«ENDIF»
			«FOR fn : p.params»
			this.«fn.name»=«fn.name»;
			«ENDFOR»
		}
		'''
	}
	
	def String getJavaType(FreeName fn) {
		if (fn.type instanceof IntType) "int"
		else if (fn.type instanceof StringType) "String"
		else if (fn.type instanceof BooleanType) "boolean"
		else if (fn.type instanceof SessionType) "Session2<TST>"
	}
	
	
	
	
	
	
	
	def void fixRecursions(Iterable<ContractDefinition> contracts) {
		
		for (c : contracts) {
			var recursions = c.eAllContents.filter(Recursion).toSet
			
			val Map<String,Integer> counts = new HashMap()
			
			
			/*
			 * fix recursion names in order to be unique
			 */
			recursions.forEach[x| 
				if (!counts.containsKey(x.name)) 
					counts.put(x.name, 0)
				
				var n = counts.put(x.name, counts.get(x.name)+1)
				
				x.name = '''rec_«c.name»_«x.name»_«n»'''
			]
		}
	}
	
	
}