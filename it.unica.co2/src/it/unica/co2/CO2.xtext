grammar it.unica.co2.CO2 with it.unica.co2.Contracts 

generate co2 "http://www.unica.it/co2/CO2"

import "http://www.unica.it/co2/Contracts" as contracts
    
CO2System:
//	importDeclarations+=ImportDeclaration*
	systemDeclaration=SystemDeclaration
	honesty=HonestyDeclaration?
	(
		contracts+=ContractDefinition |
		processes+=ProcessDefinition 
	)*
;



ImportDeclaration:
    'import' importedNamespace=QualifiedName ('.*')?;

QualifiedName:
  ID ('.' ID)*;
    
SystemDeclaration:
	"system" name=QualifiedName
;

HonestyDeclaration:
	{HonestyDeclaration} "honesty" processes+=[ProcessDefinition]*
;

ProcessDefinition:
	{ProcessDefinition} "process" name=ID ("("(params+=FreeName ("," params+=FreeName)*)?")")? "{" 
		process=(ParallelProcesses)?
	"}"
;

ParallelProcesses:
	processes+=DelimitedProcess  ("|" processes+=DelimitedProcess)?
;

DelimitedProcess:
	("("freeNames+=FreeName")")* process=Process
;

FreeName:
	name=ID ":" type=Type
;

Process:
	{EmptyProcess} value="0" |
	Sum |
	IfThenElse |
	ProcessCall |
	"(" Process ")"
;

Sum:
	prefixes+=Prefix ("+" prefixes+=Prefix)*
;

IfThenElse:
	{IfThenElse}
	'if' if=Expression
	"then "then=Next
	(=>'else' else=Next)?
;

Prefix:
	{Tau} "t" 	("." next=Next)? |
	Tell 		("." next=Next)? |
	DoOutput 	("." next=Next)? |
	DoInput 	("." next=Next)? |
	Ask			("." next=Next)?
;

Next returns Process:
	{EmptyProcess} value="0" |
	Prefix |
	IfThenElse |
	"(" ParallelProcesses ")"|
	ProcessCall
;

ProcessCall:
	reference=[ProcessDefinition] ("("(params+=Expression ("," params+=Expression)*)?")")?
;

Tell:
	"tell" session=[FreeName]  ("{" contract=Contract? "}" | contractReference=[contracts::ContractDefinition]) 
;

DoOutput:
	"do" session=[FreeName] actionName=ID "!" (value=Expression)?
;

DoInput:
	"do" session=[FreeName] actionName=ID "?" (variable=FreeName)?
;



Ask:
	"ask" session=[FreeName] ("(" formula=Formula ")" | formula=Formula)?
;

Formula:
	"True"
;





/*
 * the following part is extracted (and partially modified) from 
 * 		http://xsemantics.sourceforge.net/xsemantics-documentation/Expressions-example.html#Expressions
 * a type-system is also provided
 */
Expression:
    OrExpression;

OrExpression returns Expression:
	AndExpression (({OrExpression.left=current} '||' ) right=AndExpression)*
;

AndExpression returns Expression:
	Comparison (({AndExpression.left=current} '&&') right=Comparison)*
;

Comparison returns Expression:
       Equals
       (({Comparison.left=current} op=('>=' | '<=' | '>' | '<') ) right=Equals)*;

Equals returns Expression:
       Addition 
       (({Equals.left=current} op=("==") ) right=Addition)*;
 
Addition returns Expression:
    Multiplication
    (({Plus.left=current} '+' | {Minus.left=current} '-')
        right=Multiplication)*; 

Multiplication returns Expression:
    Prefixed (({MultiOrDiv.left=current} op=("*"|"/")) right=Prefixed)*;

Prefixed returns Expression:
    {BooleanNegation} =>"!" expression=Atomic | /* right associativity */
    {ArithmeticSigned} =>"-" expression=Atomic | /* right associativity */
    Atomic;

Atomic returns Expression:
    '(' Expression ')' |
    {NumberLiteral} value=INT |
    {StringLiteral} value=STRING |
    {BooleanLiteral} value=('true'|'false') |
    {VariableReference} ref=[FreeName]
;


Typable:
	FreeName | Expression
;

// the types will be used only internally by the type system
Type:
    {IntType} value='int' |
    {StringType} value='string' |
    {BooleanType} value='boolean' |
    {SessionType} value='session'
;

