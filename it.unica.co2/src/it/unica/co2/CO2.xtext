grammar it.unica.co2.CO2 with org.eclipse.xtext.common.Terminals

generate co2 "http://www.unica.it/co2/CO2"

    
CO2System:
//	importDeclarations+=ImportDeclaration*
	systemDeclaration=SystemDeclaration
	honesty=HonestyDeclaration?
	contractsAndProcessesDeclaration=ContractsAndProcessesDeclaration
;



ImportDeclaration:
    'import' importedNamespace=QualifiedName ('.*')?;

QualifiedName:
  ID ('.' ID)*;
    
SystemDeclaration:
	"system" name=QualifiedName
;

HonestyDeclaration:
	{HonestyDeclaration} "honesty" process=[ProcessDefinition]
;

ContractsAndProcessesDeclaration:
	{ContractsAndProcessesDeclaration} (contracts+=ContractDefinition | processes+=ProcessDefinition)*
;

ProcessDefinition:
	{ProcessDefinition} (withoutRestrictions?="process" | "co2Spec") name=ID ("("(params+=FreeName ("," params+=FreeName)*)?")")? "{" 
		process=(ParallelProcesses)?
	"}"
;

ParallelProcesses:
	processes+=DelimitedProcess  ("|" processes+=DelimitedProcess)*
;

DelimitedProcess:
	("(" (freeNames+=FreeName ("," freeNames+=FreeName)*)? ")")? process=Process
;

FreeName:
	(name=ID ":" type=Type ) | Session
;

Process:
	EmptyProcess |
	Sum |
	IfThenElse |
	TellAndWait |
	TellRetract |
	Send |
	Receive |
	"(" ParallelProcesses ")"|
	ProcessCall
;

EmptyProcess:
	{EmptyProcess} value="nil"
;

Sum:
	prefixes+=Prefix ("+" prefixes+=Prefix)*
;

SingleSum returns Sum:
	prefixes+=Prefix
;

IfThenElse:
	{IfThenElse}
	'if' if=Expression
	"then "then=Next
	(=>'else' else=Next)?
;

ProcessCall:
	reference=[ProcessDefinition] ("("(params+=Expression ("," params+=Expression)*)?")")?
;

Prefix:
	Tau			("." next=Next)? |
	Tell		("." next=Next)? |
	DoOutput	("." next=Next)? |
	DoInput 	("." next=Next)? |
	Ask			("." next=Next)? |
	Retract		("." next=Next)?
;

Next returns Process:
	EmptyProcess |
	SingleSum |
	IfThenElse |
	TellAndWait |
	TellRetract |
	Send |
	Receive |
	"(" ParallelProcesses ")"|
	ProcessCall
;


/* PREFIXES */

Tell:
	"tell" session=[FreeName]  ("{" contract=Contract? "}" | contractReference=[ContractDefinition]) 
;

Retract:
	"retract" session=[FreeName]
;

DoOutput:
	"do" session=[FreeName] actionName=ID "!" (value=Expression)?
;

DoInput:
	"do" session=[FreeName] actionName=ID "?" (variable=FreeName)?
;

Ask:
	"ask" session=[FreeName] formula=Formula? ("you never go here" public=STRING)?
;

Tau:
	{Tau} "t"
;

Formula:
	"True" | "(" "True" ")"
;





/* MACROS */

//Definition:
//	ProcessDefinition | Co2SpecDefinition
//;
//
//Co2SpecDefinition:
//	{Co2SpecDefinition} "co2Spec" name=ID ("("(params+=FreeName ("," params+=FreeName)*)?")")? "{" 
//		process=(ParallelCo2Spec)?
//	"}"
//;
//
//ParallelCo2Spec:
//	processes+=Co2Spec  ("|" processes+=Co2Spec)*
//;
//
//Co2Spec:
//	EmptyProcess |
//	IfThenElse2 |
//	TellAndWait |
//	TellRetract |
//	Send |
//	Case |
//	"(" ParallelCo2Spec ")"
//;
//
//NextCo2Spec returns Co2Spec:
//	Co2Spec | Co2SpecCall
//;
//
//IfThenElse2:
//	{IfThenElse}
//	'if' if=Expression
//	"then "then=NextCo2Spec
//	(=>'else' else=NextCo2Spec)?
//;
//
//
//
//Co2SpecCall:
//	reference=[Co2SpecDefinition] ("("(params+=Expression ("," params+=Expression)*)?")")?
//;
//

TellAndWait:
	"tellAndWait" session=Session  
	("{" contract=Contract? "}" | contractReference=[ContractDefinition])
	("." process=Next)?
;

TellRetract:
	"tell?" session=Session
	("{" contract=Contract? "}" | contractReference=[ContractDefinition])
	("." process=Next (":" rProcess=Next)?)?
;

Send:
	"send" session=[FreeName] actionName=ID "!" (value=Expression)? ("." next=Next)?
;

Receive:
	"receive" session=[FreeName] 
	"[" (actions+=Input ("+" actions+=Input)* ) ("+" timeout?="t" ("." tProcess=Next)?)? "]"
;

Input:
	actionName=ID "?" (variable=FreeName)? ("." next=Next)?
;

Session:
	name=ID
;


// ======================================================================================
// expression grammar
// ======================================================================================
/*
 * the following part is extracted (and partially modified) from 
 * 		http://xsemantics.sourceforge.net/xsemantics-documentation/Expressions-example.html#Expressions
 * a type-system is also provided
 */
Expression:
    OrExpression;

OrExpression returns Expression:
	AndExpression (({OrExpression.left=current} '||' ) right=AndExpression)*
;

AndExpression returns Expression:
	Comparison (({AndExpression.left=current} '&&') right=Comparison)*
;

Comparison returns Expression:
       Equals
       (({Comparison.left=current} op=('>=' | '<=' | '>' | '<') ) right=Equals)*;

Equals returns Expression:
       Addition 
       (({Equals.left=current} op=("==") ) right=Addition)*;
 
Addition returns Expression:
    Multiplication
    (({Plus.left=current} '+' | {Minus.left=current} '-')
        right=Multiplication)*; 

Multiplication returns Expression:
    Prefixed (({MultiOrDiv.left=current} op=("*"|"/")) right=Prefixed)*;

Prefixed returns Expression:
    {BooleanNegation} =>"!" expression=Atomic | /* right associativity */
    {ArithmeticSigned} =>"-" expression=Atomic | /* right associativity */
    Atomic;

Atomic returns Expression:
    '(' Expression ')' |
    {NumberLiteral} value=INT |
    {StringLiteral} value=STRING |
    {BooleanLiteral} value=('true'|'false') |
    {VariableReference} ref=([FreeName]|[Session])
;


Typable:
	FreeName | Expression
;

Type:
    {IntType} value='int' |
    {StringType} value='string' |
    {BooleanType} value='boolean' |
    {SessionType} value='session'
;




// ======================================================================================
// contract grammar
// ======================================================================================

ContractDefinition:
	{ContractDefinition} "contract" name=ID "{" 
		contract=(Contract)? 
	"}" 
;

Contract:
	IntSum | 
	ExtSum | 
	EmptyContract |
	"(" Contract ")"
;

EmptyContract:
	value="nil"
;

IntSum:
	actions+=IntAction ("(+)" actions+=IntAction)*
;

ExtSum:
	actions+=ExtAction ( "+"  actions+=ExtAction)*
;

NextContract returns Contract:
	SingleIntSum |
	SingleExtSum |
	EmptyContract |
	"(" Contract ")" |
	{ContractReference}	ref=[ContractDefinition]
;

SingleIntSum returns IntSum:
	actions+=IntAction
;

SingleExtSum returns ExtSum:
	actions+=ExtAction
;

IntAction:
	actionName=ID "!" (type=ActionType)? ("." next=(NextContract))?
;

ExtAction:
	actionName=ID "?" (type=ActionType)? ("." next=(NextContract))?
;

ContractReference:
	ref=[ContractDefinition]
;

ActionType: 
	{UnitActionType} value="unit" |
	{IntActionType} value="int" |
	{StringActionType} value="string"
;
