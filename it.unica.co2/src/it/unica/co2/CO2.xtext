grammar it.unica.co2.CO2 with org.eclipse.xtext.common.Terminals

generate co2 "http://www.unica.it/co2/CO2"

    
CO2System:
//	importDeclarations+=ImportDeclaration*
	systemDeclaration=SystemDeclaration
	honesty=HonestyDeclaration?
	contractsAndProcessesDeclaration=ContractsAndProcessesDeclaration
;



ImportDeclaration:
    'import' importedNamespace=QualifiedName ('.*')?;

QualifiedName:
  ID ('.' ID)*;
    
SystemDeclaration:
	"system" name=QualifiedName
;

HonestyDeclaration:
	{HonestyDeclaration} "honesty" process=[ProcessDefinition]
;

ContractsAndProcessesDeclaration:
	{ContractsAndProcessesDeclaration} (contracts+=ContractDefinition | processes+=ProcessDefinition)*
;

ProcessDefinition:
	{ProcessDefinition} (withoutRestrictions?="process" | "specification") name=ID ("("(params+=Variable ("," params+=Variable)*)?")")? "{" 
		process=(ParallelProcesses)?
	"}"
;

ParallelProcesses:
	processes+=DelimitedProcess  ("|" processes+=DelimitedProcess)*
;

DelimitedProcess:
	("(" (freeNames+=Variable ("," freeNames+=Variable)*)? ")")? process=Process
;


Variable:
	name=ID ":" type=Type
;



Process:
	EmptyProcess |
	Sum |
	IfThenElse |
	TellAndWait |
	TellRetract |
	Send |
	Receive |
	"(" ParallelProcesses ")"|
	ProcessCall
//	WaitForCompletion
;

EmptyProcess:
	{EmptyProcess} value="nil"
;

Sum:
	prefixes+=Prefix ("+" prefixes+=Prefix)*
;

SingleSum returns Sum:
	prefixes+=Prefix
;

IfThenElse:
	{IfThenElse}
	'if' if=Expression
	"then" then=Next
	(=>'else' else=Next)?
;

ProcessCall:
	reference=[ProcessDefinition] ("("(params+=Expression ("," params+=Expression)*)?")")?
;

Prefix:
	Tau			("." next=Next)? |
	Tell		("." next=Next)? |
	DoOutput	("." next=Next)? |
	DoInput 	("." next=Next)? |
	Ask			("." next=Next)? |
	Retract		("." next=Next)?
;

Next returns Process:
	EmptyProcess |
	SingleSum |
	IfThenElse |
	TellAndWait |
	TellRetract |
	Send |
	Receive |
	"(" ParallelProcesses ")"|
	ProcessCall
//	WaitForCompletion
;


/* PREFIXES */

Tell:
	"tell" session=[Variable]  ("{" contract=Contract? "}" | contractReference=[ContractDefinition]) 
;

Retract:
	"retract" session=[Variable]
;

DoOutput:
	"do" session=[Variable] actionName=ID "!" (value=Expression)?
;

DoInput:
	"do" session=[Variable] actionName=ID "?" (variable=Variable)?
;

Ask:
	"ask" session=[Variable] formula=Formula?
;

Tau:
	{Tau} "t"
;

Formula:
	"True" | "(" "True" ")"
;





/* MACROS */

TellAndWait:
	"tellAndWait" session=Session  
	("{" contract=Contract? "}" | contractReference=[ContractDefinition])
	("." process=Next)?
;

TellRetract:
	"tell?" session=Session
	("{" contract=Contract? "}" | contractReference=[ContractDefinition])
	("." process=Next (":" rProcess=Next)?)?
;

Send:
	"send" session=[Referrable] actionName=ID "!" (value=Expression)? ("." next=Next)?
;

Receive:
	"receive" session=[Referrable] 
	"[" (actions+=Input ("+" actions+=Input)* ) ("+" timeout?="t" ("." tProcess=Next)?)? "]"
;

Input:
	actionName=ID "?" (variable=Variable)? ("." next=Next)?
;

Session:
	name=ID
;

//WaitForCompletion:
//	"waitFor" "(" processes+=WProcess ("|" processes+=WProcess )* ")" "." next=Next?
//;
//
//WProcess returns Process:
//	WSend | WReceive
//;
//
//WSend returns Send:
//	"send" session=[Referrable] actionName=ID "!" (value=Expression)? ("." next=WProcess)?
//;
//
//WReceive returns Receive:
//	"receive" session=[Referrable] "[" actions+=WInput "]"
//;
//
//WInput returns Input:
//	actionName=ID "?" (variable=Variable)? ("." next=WProcess)?
//;


// ======================================================================================
// expression grammar
// ======================================================================================
/*
 * the following part is extracted (and partially modified) from 
 * 		http://xsemantics.sourceforge.net/xsemantics-documentation/Expressions-example.html#Expressions
 * a type-system is also provided
 */
Expression:
    OrExpression;

OrExpression returns Expression:
	AndExpression (({OrExpression.left=current} '||' ) right=AndExpression)*
;

AndExpression returns Expression:
	Comparison (({AndExpression.left=current} '&&') right=Comparison)*
;

Comparison returns Expression:
       Equals
       (({Comparison.left=current} op=('>=' | '<=' | '>' | '<') ) right=Equals)*;

Equals returns Expression:
       Addition 
       (({Equals.left=current} op=("==") ) right=Addition)*;
 
Addition returns Expression:
    Multiplication
    (({Plus.left=current} '+' | {Minus.left=current} '-')
        right=Multiplication)*; 

Multiplication returns Expression:
    Prefixed (({MultiOrDiv.left=current} op=("*"|"/")) right=Prefixed)*;

Prefixed returns Expression:
    {BooleanNegation} =>"!" expression=Atomic | /* right associativity */
    {ArithmeticSigned} =>"-" expression=Atomic | /* right associativity */
    Atomic;

Atomic returns Expression:
    '(' Expression ')' |
    {NumberLiteral} value=INT |
    {StringLiteral} value=STRING |
    {BooleanLiteral} value=('true'|'false') |
    {VariableReference} ref=[Referrable]
;


Typable:
	Variable | Expression
;

Referrable:
	Variable | Session
;

Type:
    {IntType} value='int' |
    {StringType} value='string' |
    {BooleanType} value='boolean' |
    {SessionType} value='session'
;




// ======================================================================================
// contract grammar
// ======================================================================================

ContractDefinition:
	{ContractDefinition} "contract" name=ID "{" 
		contract=(Contract)? 
	"}" 
;

Contract:
	IntSum | 
	ExtSum | 
	EmptyContract |
	"(" Contract ")"
;

EmptyContract:
	value="nil"
;

IntSum:
	actions+=IntAction ("(+)" actions+=IntAction)*
;

ExtSum:
	actions+=ExtAction ( "+"  actions+=ExtAction)*
;

NextContract returns Contract:
	SingleIntSum |
	SingleExtSum |
	EmptyContract |
	"(" Contract ")" |
	{ContractReference}	ref=[ContractDefinition]
;

SingleIntSum returns IntSum:
	actions+=IntAction
;

SingleExtSum returns ExtSum:
	actions+=ExtAction
;

IntAction:
	actionName=ID "!" (type=ActionType)? ("." next=(NextContract))?
;

ExtAction:
	actionName=ID "?" (type=ActionType)? ("." next=(NextContract))?
;

ActionType: 
	{UnitActionType} value="unit" |
	{IntActionType} value="int" |
	{StringActionType} value="string"
;
