grammar it.unica.co2.CO2 with org.eclipse.xtext.common.Terminals

generate co2 "http://www.unica.it/co2/CO2"

    
CO2System:
//	importDeclarations+=ImportDeclaration*
	systemDeclaration=SystemDeclaration
	honesty=HonestyDeclaration?
	contractsAndProcessesDeclaration=ContractsAndProcessesDeclaration
;



ImportDeclaration:
    'import' importedNamespace=QualifiedName ('.*')?;

QualifiedName:
  ID ('.' ID)*;
    
SystemDeclaration:
	"system" name=QualifiedName
;

HonestyDeclaration:
	{HonestyDeclaration} "honesty" process=[ProcessDefinition]
;

ContractsAndProcessesDeclaration:
	{ContractsAndProcessesDeclaration} (contracts+=ContractDefinition | processes+=ProcessDefinition)*
;

ProcessDefinition:
	{ProcessDefinition} "process" name=ID ("("(params+=FreeName ("," params+=FreeName)*)?")")? "{" 
		process=(ParallelProcesses)?
	"}"
;

ParallelProcesses:
	processes+=DelimitedProcess  ("|" processes+=DelimitedProcess)*
;

DelimitedProcess:
	("("freeNames+=FreeName")")* process=Process
;

FreeName:
	name=ID ":" type=Type
;

Process:
	EmptyProcess |
	Sum |
	IfThenElse |
	ProcessCall |
	"(" ParallelProcesses ")"
;

EmptyProcess:
	{EmptyProcess} value="nil"
;

Sum:
	prefixes+=Prefix ("+" prefixes+=Prefix)*
;

IfThenElse:
	{IfThenElse}
	'if' if=Expression
	"then "then=Next
	(=>'else' else=Next)?
;

Prefix:
	{Tau} "t" 	("." next=Next)? |
	Tell 		("." next=Next)? |
	DoOutput 	("." next=Next)? |
	DoInput 	("." next=Next)? |
	Ask			("." next=Next)?
;

Next returns Process:
	EmptyProcess |
	Prefix |
	IfThenElse |
	"(" ParallelProcesses ")"|
	ProcessCall
;

ProcessCall:
	reference=[ProcessDefinition] ("("(params+=Expression ("," params+=Expression)*)?")")?
;

Tell:
	"tell" session=[FreeName]  ("{" contract=Contract? "}" | contractReference=[ContractDefinition]) 
;

DoOutput:
	"do" session=[FreeName] actionName=ID "!" (value=Expression)?
;

DoInput:
	"do" session=[FreeName] actionName=ID "?" (variable=FreeName)?
;



Ask:
	"ask" session=[FreeName] ("(" formula=Formula ")" | formula=Formula)?
;

Formula:
	"True"
;




// ======================================================================================
// expression grammar
// ======================================================================================
/*
 * the following part is extracted (and partially modified) from 
 * 		http://xsemantics.sourceforge.net/xsemantics-documentation/Expressions-example.html#Expressions
 * a type-system is also provided
 */
Expression:
    OrExpression;

OrExpression returns Expression:
	AndExpression (({OrExpression.left=current} '||' ) right=AndExpression)*
;

AndExpression returns Expression:
	Comparison (({AndExpression.left=current} '&&') right=Comparison)*
;

Comparison returns Expression:
       Equals
       (({Comparison.left=current} op=('>=' | '<=' | '>' | '<') ) right=Equals)*;

Equals returns Expression:
       Addition 
       (({Equals.left=current} op=("==") ) right=Addition)*;
 
Addition returns Expression:
    Multiplication
    (({Plus.left=current} '+' | {Minus.left=current} '-')
        right=Multiplication)*; 

Multiplication returns Expression:
    Prefixed (({MultiOrDiv.left=current} op=("*"|"/")) right=Prefixed)*;

Prefixed returns Expression:
    {BooleanNegation} =>"!" expression=Atomic | /* right associativity */
    {ArithmeticSigned} =>"-" expression=Atomic | /* right associativity */
    Atomic;

Atomic returns Expression:
    '(' Expression ')' |
    {NumberLiteral} value=INT |
    {StringLiteral} value=STRING |
    {BooleanLiteral} value=('true'|'false') |
    {VariableReference} ref=[FreeName]
;


Typable:
	FreeName | Expression
;

// the types will be used only internally by the type system
Type:
    {IntType} value='int' |
    {StringType} value='string' |
    {BooleanType} value='boolean' |
    {SessionType} value='session'
;





// ======================================================================================
// contract grammar
// ======================================================================================

ContractDefinition:
	{ContractDefinition} "contract" name=ID "{" 
		contract=(Contract)? 
	"}" 
;

Contract:
	IntSum | 
	ExtSum | 
	Recursion |
	{EmptyContract} value="nil" |
	"(" Contract ")"
;

IntSum:
	actions+=IntAction ("(+)" actions+=IntAction)*
;

ExtSum:
	actions+=ExtAction ( "+"  actions+=ExtAction)*
;

Recursion:
	"rec" name=ID "." body=NextContract
;

NextContract returns Contract:
	SingleIntSum |
	SingleExtSum |
	{EmptyContract} value="nil" |
	"(" Contract ")"
;

SingleIntSum returns IntSum:
	actions+=IntAction
;

SingleExtSum returns ExtSum:
	actions+=ExtAction
;

IntAction:
	actionName=ID "!" (type=ActionType)? ("." next=AbstractNextContract)?
;

ExtAction:
	actionName=ID "?" (type=ActionType)? ("." next=AbstractNextContract)?
;

AbstractNextContract returns Contract:
	next=NextContract |
	ContractReference
;

ContractReference:
	ref=[Referrable]
;

Referrable:
	ContractDefinition | Recursion
;

ActionType: 
	{UnitActionType} "unit" |
	{IntActionType} "int" |
	{StringActionType} "string"
;
