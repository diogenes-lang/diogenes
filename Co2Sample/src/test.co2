
contract C {
	a!. ( a1? int + a2?) (+) b!
}


specification P(n:int, x:session) {
	tellAndWait x { a?string . b! int} .
	receive a?[n:string] from x .  
	send b![n] to x .
	tellAndWait x { a?string . b! int} .
	send b![n] to x
}


specification P100 {
	tellAndReturn x {a!} . P1(x)
}

specification P0 {
	tellAndReturn x {b!} . P1(x)
}

specification P1 (x:session) {
	send b! to x . P1(x)
}

specification P2 (x:session) {
	P2(x)
}

contract D {
	a! . (a? + b?) (+) b!
}

specification Foo {
	tellAndWait x D .
	switch *:int {
		case 0 => send a! to x . receive a?b? from x
		case 1 => send b![42] to x
		case 2 => if *:boolean then send b! to x
		default:
			receive {
				a? from x
				b? from x
			}
	}	
}