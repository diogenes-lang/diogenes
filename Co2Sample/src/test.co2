/*
 * empty contract
 */
contract c1 {
	a! . b? (+) c!
}

contract c2 {
	( ( ( nil ) ) )
}

/*
 * single element
 */
contract c3 {
	a!
}

/*
 * simple internal sum
 */
contract c4 {
	a! (+) b! (+) c!
}

/*
 * simple external sum
 */
contract c5 {
	a? + b? + c?
}

/*
 * simple recursion
 */
contract c6 {
	a! . c6
}

contract c7 {
	a? . c7
}

contract c8 {
	a! . ( a! (+) b! ) (+) b! . ( a? + b? ) (+) c! . c? . c7
}

//contract scope {
//	a!. (
//		rec A . (
//			a!.A (+) b!. (
//				rec B. (
//					a?.A + b?.B + c?.(
//						rec C. (
//							a!.A (+) b!.B (+) c!.C 
//						)
//					)
//				)
//			)
//		)
//	) (+) b!. nil
//}
//
//contract shadows {
//	rec A. (
//		a!.A (+) b!. (
//			rec A. (	//hide the first definition
//				c!. A	//reference to the last declaration
//			)
//		)
//	)
//}

/*
 * Contracts with name
 */
contract bank {
	a? + b?
}

contract police {
	a! (+) b!
}

/*
 * Reference example
 */
contract foo {
	a! . nil (+) b! . police
}

contract CA {
	order?int . ( amount!unit . pay?unit (+) abort!unit )
}

contract CI {
	reqI!unit . ( okI?unit + abortI?unit )
}

contract C {
	a! . ( a1?int + a2? . b! ) (+) b!
}

specification P100 {
	tellAndReturn x { a! } . P1 ( x )
}

specification P ( n:int, x:session ) {
	tell x { a?string . b!int } . receive a?[n:string] from x . send b![n] to x .
	tell x { a?string . b!int } . send b! to x

}

specification Bo2 ( x:session ) {
	if *
	then send b! to x
	else send b! to x
}

specification Bo ( x:session ) {
	if *
	then send b! to x . send b! to x . send b! to x
	else send b! to x . send b! to x

}

specification P0 {
	tellAndReturn x { b! } . P1 ( x )
}

specification P1 ( x:session ) {
	send b! to x . P1 ( x )
}

specification P2 ( x:session ) {
	P2 ( x )
}

contract D {
	a! . ( a? + b? ) (+) b! (+) fooo!
}

specification Foo {
	tell x D .
	switch * {
		case "0" -> send a! to x . receive a? b? from x
		case "1" ->
			receive {
				a? from x
				b? from x
			}
		case "2" ->
			if *
			then send b! to x
		default -> send b![42] to x
	}
}

contract A {
	a!
}

specification Poo {
	tell x A . tell y B . send a! to x
	after * -> send a! to x
}

contract B {
	b!
}

specification Parall ( x:session, y:session ) {
	send a! to x |
	send b! to x |
	send@x a! |
	receive {
		@x a?
		@y b?
	} |
	receive@y a2? a1?[n:int]
}
